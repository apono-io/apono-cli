// Package aponoapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package aponoapi

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

const (
	AuthorizationScopes = "Authorization.Scopes"
)

// Defines values for AccessStatus.
const (
	AccessStatusAPPROVED AccessStatus = "APPROVED"
	AccessStatusEXPIRED  AccessStatus = "EXPIRED"
	AccessStatusFAILED   AccessStatus = "FAILED"
	AccessStatusGRANTED  AccessStatus = "GRANTED"
	AccessStatusPENDING  AccessStatus = "PENDING"
	AccessStatusREJECTED AccessStatus = "REJECTED"
	AccessStatusREVOKING AccessStatus = "REVOKING"
)

// Defines values for AccessStatusModel.
const (
	AccessStatusModelAPPROVED AccessStatusModel = "APPROVED"
	AccessStatusModelEXPIRED  AccessStatusModel = "EXPIRED"
	AccessStatusModelFAILED   AccessStatusModel = "FAILED"
	AccessStatusModelGRANTED  AccessStatusModel = "GRANTED"
	AccessStatusModelPENDING  AccessStatusModel = "PENDING"
	AccessStatusModelREJECTED AccessStatusModel = "REJECTED"
	AccessStatusModelREVOKING AccessStatusModel = "REVOKING"
)

// Defines values for ApproverTypeModel.
const (
	ApproverTypeModelCONTEXTATTRIBUTE ApproverTypeModel = "CONTEXT_ATTRIBUTE"
	ApproverTypeModelGROUP            ApproverTypeModel = "GROUP"
	ApproverTypeModelUSER             ApproverTypeModel = "USER"
)

// Defines values for DayOfWeek.
const (
	FRIDAY    DayOfWeek = "FRIDAY"
	MONDAY    DayOfWeek = "MONDAY"
	SATURDAY  DayOfWeek = "SATURDAY"
	SUNDAY    DayOfWeek = "SUNDAY"
	THURSDAY  DayOfWeek = "THURSDAY"
	TUESDAY   DayOfWeek = "TUESDAY"
	WEDNESDAY DayOfWeek = "WEDNESDAY"
)

// Defines values for FilterResultContext.
const (
	FilterResultContextAccessFlowName FilterResultContext = "AccessFlowName"
	FilterResultContextAccessTarget   FilterResultContext = "AccessTarget"
	FilterResultContextApprovers      FilterResultContext = "Approvers"
	FilterResultContextGrantees       FilterResultContext = "Grantees"
	FilterResultContextTriggerType    FilterResultContext = "TriggerType"
)

// Defines values for FilterResultContextType.
const (
	FilterResultContextTypeAccessFlowName      FilterResultContextType = "AccessFlowName"
	FilterResultContextTypeContextAttribute    FilterResultContextType = "ContextAttribute"
	FilterResultContextTypeGroup               FilterResultContextType = "Group"
	FilterResultContextTypeMetadata            FilterResultContextType = "Metadata"
	FilterResultContextTypePermissions         FilterResultContextType = "Permissions"
	FilterResultContextTypeResource            FilterResultContextType = "Resource"
	FilterResultContextTypeResourceIntegration FilterResultContextType = "ResourceIntegration"
	FilterResultContextTypeUser                FilterResultContextType = "User"
)

// Defines values for GranteeTypeModel.
const (
	GranteeTypeModelCONTEXTATTRIBUTE GranteeTypeModel = "CONTEXT_ATTRIBUTE"
	GranteeTypeModelEXTERNALEMAIL    GranteeTypeModel = "EXTERNAL_EMAIL"
	GranteeTypeModelGROUP            GranteeTypeModel = "GROUP"
	GranteeTypeModelUSER             GranteeTypeModel = "USER"
)

// Defines values for IntegrationStatus.
const (
	Active       IntegrationStatus = "Active"
	Disabled     IntegrationStatus = "Disabled"
	Error        IntegrationStatus = "Error"
	Initializing IntegrationStatus = "Initializing"
	Refreshing   IntegrationStatus = "Refreshing"
	Warning      IntegrationStatus = "Warning"
)

// Defines values for ReportField.
const (
	ReportFieldAccessFlow     ReportField = "access_flow"
	ReportFieldIntegration    ReportField = "integration"
	ReportFieldJustification  ReportField = "justification"
	ReportFieldPermissions    ReportField = "permissions"
	ReportFieldRequestDate    ReportField = "request_date"
	ReportFieldRequestId      ReportField = "request_id"
	ReportFieldRequestorEmail ReportField = "requestor_email"
	ReportFieldRequestorName  ReportField = "requestor_name"
	ReportFieldResourceType   ReportField = "resource_type"
	ReportFieldResources      ReportField = "resources"
	ReportFieldStatus         ReportField = "status"
)

// Defines values for TriggerType.
const (
	SHARELINK   TriggerType = "SHARE_LINK"
	USERREQUEST TriggerType = "USER_REQUEST"
)

// AccessFlowFilterResult defines model for AccessFlowFilterResult.
type AccessFlowFilterResult struct {
	AccessFlowId string         `json:"access_flow_id"`
	Results      []FilterResult `json:"results"`
}

// AccessFlowModelV3 defines model for AccessFlowModelV3.
type AccessFlowModelV3 struct {
	AccessTargets         []AccessTargetModelV3 `json:"access_targets"`
	Active                bool                  `json:"active"`
	Approvers             []ApproverModel       `json:"approvers"`
	CreatedDate           Instant               `json:"created_date"`
	Grantees              []GranteeModel        `json:"grantees"`
	Id                    string                `json:"id"`
	JustificationRequired bool                  `json:"justification_required"`
	Name                  string                `json:"name"`
	RequireAllApprovers   *bool                 `json:"require_all_approvers"`
	RevokeAfterInSec      int32                 `json:"revoke_after_in_sec"`
	Timeframe             *Timeframe            `json:"timeframe"`
	TriggerType           TriggerType           `json:"trigger_type"`
}

// AccessRequest defines model for AccessRequest.
type AccessRequest struct {
	FriendlyRequestId string            `json:"friendly_request_id"`
	IntegrationId     string            `json:"integration_id"`
	Justification     string            `json:"justification"`
	Permissions       []string          `json:"permissions"`
	RequestId         string            `json:"request_id"`
	ResourceIds       []string          `json:"resource_ids"`
	Status            AccessStatusModel `json:"status"`
	UserId            string            `json:"user_id"`
}

// AccessStatus defines model for AccessStatus.
type AccessStatus string

// AccessStatusModel defines model for AccessStatusModel.
type AccessStatusModel string

// AccessTargetModelV3 defines model for AccessTargetModelV3.
type AccessTargetModelV3 struct {
	IntegrationId       string       `json:"integration_id"`
	Permissions         []string     `json:"permissions"`
	ResourceTagMatchers []TagModelV3 `json:"resource_tag_matchers"`
	ResourceType        string       `json:"resource_type"`
}

// ActivityReportJsonExportModel defines model for ActivityReportJsonExportModel.
type ActivityReportJsonExportModel struct {
	AccessFlow     *string   `json:"access_flow"`
	Integration    *string   `json:"integration"`
	Justification  *string   `json:"justification"`
	Permissions    *[]string `json:"permissions"`
	RequestDate    *string   `json:"request_date"`
	RequestId      *string   `json:"request_id"`
	RequestorEmail *string   `json:"requestor_email"`
	RequestorName  *string   `json:"requestor_name"`
	ResourceType   *string   `json:"resource_type"`
	Resources      *[]string `json:"resources"`
	Status         *string   `json:"status"`
}

// ApproverModel defines model for ApproverModel.
type ApproverModel struct {
	Id   string            `json:"id"`
	Type ApproverTypeModel `json:"type"`
}

// ApproverTypeModel defines model for ApproverTypeModel.
type ApproverTypeModel string

// ConnectDetailsResponse defines model for ConnectDetailsResponse.
type ConnectDetailsResponse struct {
	Details string `json:"details"`
}

// ConnectionMetadata defines model for ConnectionMetadata.
type ConnectionMetadata = map[string]interface{}

// Connector defines model for Connector.
type Connector struct {
	ConnectorId   string   `json:"connector_id"`
	LastConnected *Instant `json:"last_connected"`
	Status        string   `json:"status"`
}

// CreateAccessFlowRequestV3 defines model for CreateAccessFlowRequestV3.
type CreateAccessFlowRequestV3 struct {
	AccessTargets         []AccessTargetModelV3 `json:"access_targets"`
	Active                bool                  `json:"active"`
	Approvers             []ApproverModel       `json:"approvers"`
	Grantees              []GranteeModel        `json:"grantees"`
	JustificationRequired bool                  `json:"justification_required"`
	Name                  string                `json:"name"`
	RequireAllApprovers   *bool                 `json:"require_all_approvers"`
	RevokeAfterInSec      int32                 `json:"revoke_after_in_sec"`
	Timeframe             *Timeframe            `json:"timeframe"`
	TriggerType           TriggerType           `json:"trigger_type"`
}

// CreateAccessRequest defines model for CreateAccessRequest.
type CreateAccessRequest struct {
	IntegrationId string   `json:"integration_id"`
	Justification string   `json:"justification"`
	Permissions   []string `json:"permissions"`
	ResourceIds   []string `json:"resource_ids"`
	UserId        string   `json:"user_id"`
}

// CreateIntegration defines model for CreateIntegration.
type CreateIntegration struct {
	Metadata      map[string]interface{} `json:"metadata"`
	Name          string                 `json:"name"`
	ProvisionerId *string                `json:"provisioner_id"`
	SecretConfig  *SecretConfig          `json:"secret_config"`
	Type          string                 `json:"type"`
}

// DayOfWeek defines model for DayOfWeek.
type DayOfWeek string

// FilterResult defines model for FilterResult.
type FilterResult struct {
	Context       FilterResultContext     `json:"context"`
	FilterPhrase  string                  `json:"filter_phrase"`
	MatchedValues []string                `json:"matched_values"`
	Type          FilterResultContextType `json:"type"`
}

// FilterResultContext defines model for FilterResultContext.
type FilterResultContext string

// FilterResultContextType defines model for FilterResultContextType.
type FilterResultContextType string

// GranteeModel defines model for GranteeModel.
type GranteeModel struct {
	Id   string           `json:"id"`
	Type GranteeTypeModel `json:"type"`
}

// GranteeTypeModel defines model for GranteeTypeModel.
type GranteeTypeModel string

// IdentityModel2 defines model for IdentityModel2.
type IdentityModel2 struct {
	Id   string `json:"id"`
	Name string `json:"name"`
	Type string `json:"type"`
}

// Integration defines model for Integration.
type Integration struct {
	Connection    *ConnectionMetadata    `json:"connection"`
	Details       *string                `json:"details"`
	Id            string                 `json:"id"`
	LastSyncTime  *Instant               `json:"last_sync_time"`
	Metadata      map[string]interface{} `json:"metadata"`
	Name          string                 `json:"name"`
	ProvisionerId *string                `json:"provisioner_id"`
	SecretConfig  *SecretConfig          `json:"secret_config"`
	Status        IntegrationStatus      `json:"status"`
	Type          string                 `json:"type"`
}

// IntegrationConfig defines model for IntegrationConfig.
type IntegrationConfig struct {
	Description          string                   `json:"description"`
	Name                 string                   `json:"name"`
	Params               []IntegrationConfigParam `json:"params"`
	RequiresSecret       bool                     `json:"requires_secret"`
	SupportedSecretTypes []string                 `json:"supported_secret_types"`
	Type                 string                   `json:"type"`
}

// IntegrationConfigParam defines model for IntegrationConfigParam.
type IntegrationConfigParam struct {
	Default string   `json:"default"`
	Id      string   `json:"id"`
	Label   string   `json:"label"`
	Values  []string `json:"values"`
}

// IntegrationStatus defines model for IntegrationStatus.
type IntegrationStatus string

// MessageResponse defines model for MessageResponse.
type MessageResponse struct {
	Message string `json:"message"`
}

// PaginatedAccessFlowV3SearchResponse defines model for PaginatedAccessFlowV3SearchResponse.
type PaginatedAccessFlowV3SearchResponse struct {
	Data         []AccessFlowModelV3       `json:"data"`
	FilterResult *[]AccessFlowFilterResult `json:"filter_result"`
}

// PaginatedResponseAccessRequestV3 defines model for PaginatedResponseAccessRequestV3.
type PaginatedResponseAccessRequestV3 struct {
	Data       []AccessRequest `json:"data"`
	Pagination PaginationInfo  `json:"pagination"`
}

// PaginatedResponseActivityReportJsonExportModel defines model for PaginatedResponseActivityReportJsonExportModel.
type PaginatedResponseActivityReportJsonExportModel struct {
	Data       []ActivityReportJsonExportModel `json:"data"`
	Pagination PaginationInfo                  `json:"pagination"`
}

// PaginatedResponseIdentityModelV2 defines model for PaginatedResponseIdentityModelV2.
type PaginatedResponseIdentityModelV2 struct {
	Data       []IdentityModel2 `json:"data"`
	Pagination PaginationInfo   `json:"pagination"`
}

// PaginatedResponseIntegrationConfigPublicModel defines model for PaginatedResponseIntegrationConfigPublicModel.
type PaginatedResponseIntegrationConfigPublicModel struct {
	Data       []IntegrationConfig `json:"data"`
	Pagination PaginationInfo      `json:"pagination"`
}

// PaginatedResponseIntegrationModel defines model for PaginatedResponseIntegrationModel.
type PaginatedResponseIntegrationModel struct {
	Data       []Integration  `json:"data"`
	Pagination PaginationInfo `json:"pagination"`
}

// PaginatedResponsePermissionV3Response defines model for PaginatedResponsePermissionV3Response.
type PaginatedResponsePermissionV3Response struct {
	Data       []PermissionV3 `json:"data"`
	Pagination PaginationInfo `json:"pagination"`
}

// PaginatedResponseResourceV3Response defines model for PaginatedResponseResourceV3Response.
type PaginatedResponseResourceV3Response struct {
	Data       []ResourceV3   `json:"data"`
	Pagination PaginationInfo `json:"pagination"`
}

// PaginatedResponseSelectableIntegrationV3 defines model for PaginatedResponseSelectableIntegrationV3.
type PaginatedResponseSelectableIntegrationV3 struct {
	Data       []SelectableIntegration `json:"data"`
	Pagination PaginationInfo          `json:"pagination"`
}

// PaginatedResponseSelectableResourceTypeV3 defines model for PaginatedResponseSelectableResourceTypeV3.
type PaginatedResponseSelectableResourceTypeV3 struct {
	Data       []SelectableResourceType `json:"data"`
	Pagination PaginationInfo           `json:"pagination"`
}

// PaginatedResponseSelectableResourceV3 defines model for PaginatedResponseSelectableResourceV3.
type PaginatedResponseSelectableResourceV3 struct {
	Data       []SelectableResource `json:"data"`
	Pagination PaginationInfo       `json:"pagination"`
}

// PaginatedResponseUserModel defines model for PaginatedResponseUserModel.
type PaginatedResponseUserModel struct {
	Data       []UserModel    `json:"data"`
	Pagination PaginationInfo `json:"pagination"`
}

// PaginationInfo defines model for PaginationInfo.
type PaginationInfo struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
	Total  int32 `json:"total"`
}

// PermissionV3 defines model for PermissionV3.
type PermissionV3 struct {
	Id           string `json:"id"`
	Name         string `json:"name"`
	ResourceType string `json:"resource_type"`
}

// ReportField defines model for ReportField.
type ReportField string

// ResourceV3 defines model for ResourceV3.
type ResourceV3 struct {
	Id   string `json:"id"`
	Name string `json:"name"`
	Type string `json:"type"`
}

// SecretConfig defines model for SecretConfig.
type SecretConfig = map[string]interface{}

// SelectableIntegration defines model for SelectableIntegration.
type SelectableIntegration struct {
	Id string `json:"id"`
}

// SelectablePermissionsResponse defines model for SelectablePermissionsResponse.
type SelectablePermissionsResponse struct {
	AllowMultiple bool           `json:"allow_multiple"`
	Data          []string       `json:"data"`
	Pagination    PaginationInfo `json:"pagination"`
}

// SelectableResource defines model for SelectableResource.
type SelectableResource struct {
	Id   string `json:"id"`
	Name string `json:"name"`
	Type string `json:"type"`
}

// SelectableResourceType defines model for SelectableResourceType.
type SelectableResourceType struct {
	Id   string `json:"id"`
	Name string `json:"name"`
}

// TagModelV3 defines model for TagModelV3.
type TagModelV3 struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

// Timeframe defines model for Timeframe.
type Timeframe struct {
	DaysInWeek   []DayOfWeek `json:"days_in_week"`
	EndTimeSec   int64       `json:"end_time_sec"`
	StartTimeSec int64       `json:"start_time_sec"`
	TimeZone     string      `json:"time_zone"`
}

// TriggerType defines model for TriggerType.
type TriggerType string

// UpdateAccessFlowModelV3 defines model for UpdateAccessFlowModelV3.
type UpdateAccessFlowModelV3 struct {
	AccessTargets         []AccessTargetModelV3 `json:"access_targets"`
	Active                bool                  `json:"active"`
	Approvers             []ApproverModel       `json:"approvers"`
	Grantees              []GranteeModel        `json:"grantees"`
	JustificationRequired bool                  `json:"justification_required"`
	Name                  string                `json:"name"`
	RequireAllApprovers   *bool                 `json:"require_all_approvers"`
	RevokeAfterInSec      int32                 `json:"revoke_after_in_sec"`
	Timeframe             *Timeframe            `json:"timeframe"`
	TriggerType           TriggerType           `json:"trigger_type"`
}

// UpdateIntegration defines model for UpdateIntegration.
type UpdateIntegration struct {
	Metadata      map[string]interface{} `json:"metadata"`
	Name          string                 `json:"name"`
	ProvisionerId *string                `json:"provisioner_id"`
	SecretConfig  *SecretConfig          `json:"secret_config"`
}

// UserModel defines model for UserModel.
type UserModel struct {
	Active    bool   `json:"active"`
	Email     string `json:"email"`
	FirstName string `json:"first_name"`
	Id        string `json:"id"`
	LastName  string `json:"last_name"`
}

// ListAccessFlowsParams defines parameters for ListAccessFlows.
type ListAccessFlowsParams struct {
	Filters    *string `form:"filters,omitempty" json:"filters,omitempty"`
	OnlyActive *bool   `form:"only_active,omitempty" json:"only_active,omitempty"`
}

// ListAccessRequestsParams defines parameters for ListAccessRequests.
type ListAccessRequestsParams struct {
	DaysOffset *int64  `form:"days_offset,omitempty" json:"days_offset,omitempty"`
	UserId     *string `form:"user_id,omitempty" json:"user_id,omitempty"`
}

// ListActivityParams defines parameters for ListActivity.
type ListActivityParams struct {
	EndDate             *int64          `form:"end_date,omitempty" json:"end_date,omitempty"`
	Fields              *[]ReportField  `form:"fields,omitempty" json:"fields,omitempty"`
	FilterIntegrationId *[]string       `form:"filter[integration_id],omitempty" json:"filter[integration_id],omitempty"`
	FilterPermission    *[]string       `form:"filter[permission],omitempty" json:"filter[permission],omitempty"`
	FilterRequestorId   *[]string       `form:"filter[requestor_id],omitempty" json:"filter[requestor_id],omitempty"`
	FilterResource      *[]string       `form:"filter[resource],omitempty" json:"filter[resource],omitempty"`
	FilterResourceType  *[]string       `form:"filter[resource_type],omitempty" json:"filter[resource_type],omitempty"`
	FilterStatus        *[]AccessStatus `form:"filter[status],omitempty" json:"filter[status],omitempty"`
	StartDate           *int64          `form:"start_date,omitempty" json:"start_date,omitempty"`
}

// GetSelectableIntegrationsParams defines parameters for GetSelectableIntegrations.
type GetSelectableIntegrationsParams struct {
	UserId *string `form:"user_id,omitempty" json:"user_id,omitempty"`
}

// GetSelectableResourceTypesParams defines parameters for GetSelectableResourceTypes.
type GetSelectableResourceTypesParams struct {
	UserId *string `form:"user_id,omitempty" json:"user_id,omitempty"`
}

// GetSelectablePermissionsParams defines parameters for GetSelectablePermissions.
type GetSelectablePermissionsParams struct {
	UserId *string `form:"user_id,omitempty" json:"user_id,omitempty"`
}

// GetSelectableResourcesParams defines parameters for GetSelectableResources.
type GetSelectableResourcesParams struct {
	UserId *string `form:"user_id,omitempty" json:"user_id,omitempty"`
}

// CreateIntegrationV2JSONRequestBody defines body for CreateIntegrationV2 for application/json ContentType.
type CreateIntegrationV2JSONRequestBody = CreateIntegration

// UpdateIntegrationV2JSONRequestBody defines body for UpdateIntegrationV2 for application/json ContentType.
type UpdateIntegrationV2JSONRequestBody = UpdateIntegration

// CreateAccessFlowJSONRequestBody defines body for CreateAccessFlow for application/json ContentType.
type CreateAccessFlowJSONRequestBody = CreateAccessFlowRequestV3

// UpdateAccessFlowJSONRequestBody defines body for UpdateAccessFlow for application/json ContentType.
type UpdateAccessFlowJSONRequestBody = UpdateAccessFlowModelV3

// CreateAccessRequestJSONRequestBody defines body for CreateAccessRequest for application/json ContentType.
type CreateAccessRequestJSONRequestBody = CreateAccessRequest

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListConnectors request
	ListConnectors(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListIdentities request
	ListIdentities(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListIntegrationsV2 request
	ListIntegrationsV2(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateIntegrationV2 request with any body
	CreateIntegrationV2WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateIntegrationV2(ctx context.Context, body CreateIntegrationV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListIntegrationConfigs request
	ListIntegrationConfigs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIntegrationConfig request
	GetIntegrationConfig(ctx context.Context, pType string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteIntegrationV2 request
	DeleteIntegrationV2(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIntegrationV2 request
	GetIntegrationV2(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateIntegrationV2 request with any body
	UpdateIntegrationV2WithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateIntegrationV2(ctx context.Context, id string, body UpdateIntegrationV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RefreshIntegrationV2 request
	RefreshIntegrationV2(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUsers request
	ListUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUser request
	GetUser(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAccessFlows request
	ListAccessFlows(ctx context.Context, params *ListAccessFlowsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAccessFlow request with any body
	CreateAccessFlowWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAccessFlow(ctx context.Context, body CreateAccessFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAccessFlow request
	DeleteAccessFlow(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAccessFlow request
	GetAccessFlow(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAccessFlow request with any body
	UpdateAccessFlowWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAccessFlow(ctx context.Context, id string, body UpdateAccessFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAccessRequests request
	ListAccessRequests(ctx context.Context, params *ListAccessRequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAccessRequest request with any body
	CreateAccessRequestWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAccessRequest(ctx context.Context, body CreateAccessRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAccessRequest request
	GetAccessRequest(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAccessRequestDetails request
	GetAccessRequestDetails(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResetAccessRequestCredentials request
	ResetAccessRequestCredentials(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListActivity request
	ListActivity(ctx context.Context, params *ListActivityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIntegrationPermissions request
	GetIntegrationPermissions(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIntegrationResources request
	GetIntegrationResources(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSelectableIntegrations request
	GetSelectableIntegrations(ctx context.Context, params *GetSelectableIntegrationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSelectableResourceTypes request
	GetSelectableResourceTypes(ctx context.Context, integrationId string, params *GetSelectableResourceTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSelectablePermissions request
	GetSelectablePermissions(ctx context.Context, integrationId string, resourceType string, params *GetSelectablePermissionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSelectableResources request
	GetSelectableResources(ctx context.Context, integrationId string, resourceType string, params *GetSelectableResourcesParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListConnectors(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListConnectorsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListIdentities(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListIdentitiesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListIntegrationsV2(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListIntegrationsV2Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIntegrationV2WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIntegrationV2RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIntegrationV2(ctx context.Context, body CreateIntegrationV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIntegrationV2Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListIntegrationConfigs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListIntegrationConfigsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIntegrationConfig(ctx context.Context, pType string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIntegrationConfigRequest(c.Server, pType)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteIntegrationV2(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteIntegrationV2Request(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIntegrationV2(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIntegrationV2Request(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateIntegrationV2WithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateIntegrationV2RequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateIntegrationV2(ctx context.Context, id string, body UpdateIntegrationV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateIntegrationV2Request(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RefreshIntegrationV2(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRefreshIntegrationV2Request(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUsersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUser(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAccessFlows(ctx context.Context, params *ListAccessFlowsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAccessFlowsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAccessFlowWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAccessFlowRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAccessFlow(ctx context.Context, body CreateAccessFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAccessFlowRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAccessFlow(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAccessFlowRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAccessFlow(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccessFlowRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAccessFlowWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAccessFlowRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAccessFlow(ctx context.Context, id string, body UpdateAccessFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAccessFlowRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAccessRequests(ctx context.Context, params *ListAccessRequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAccessRequestsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAccessRequestWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAccessRequestRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAccessRequest(ctx context.Context, body CreateAccessRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAccessRequestRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAccessRequest(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccessRequestRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAccessRequestDetails(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccessRequestDetailsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetAccessRequestCredentials(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetAccessRequestCredentialsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListActivity(ctx context.Context, params *ListActivityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListActivityRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIntegrationPermissions(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIntegrationPermissionsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIntegrationResources(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIntegrationResourcesRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSelectableIntegrations(ctx context.Context, params *GetSelectableIntegrationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSelectableIntegrationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSelectableResourceTypes(ctx context.Context, integrationId string, params *GetSelectableResourceTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSelectableResourceTypesRequest(c.Server, integrationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSelectablePermissions(ctx context.Context, integrationId string, resourceType string, params *GetSelectablePermissionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSelectablePermissionsRequest(c.Server, integrationId, resourceType, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSelectableResources(ctx context.Context, integrationId string, resourceType string, params *GetSelectableResourcesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSelectableResourcesRequest(c.Server, integrationId, resourceType, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListConnectorsRequest generates requests for ListConnectors
func NewListConnectorsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/connectors")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListIdentitiesRequest generates requests for ListIdentities
func NewListIdentitiesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/identities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListIntegrationsV2Request generates requests for ListIntegrationsV2
func NewListIntegrationsV2Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/integrations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateIntegrationV2Request calls the generic CreateIntegrationV2 builder with application/json body
func NewCreateIntegrationV2Request(server string, body CreateIntegrationV2JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateIntegrationV2RequestWithBody(server, "application/json", bodyReader)
}

// NewCreateIntegrationV2RequestWithBody generates requests for CreateIntegrationV2 with any type of body
func NewCreateIntegrationV2RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/integrations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListIntegrationConfigsRequest generates requests for ListIntegrationConfigs
func NewListIntegrationConfigsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/integrations-catalog")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIntegrationConfigRequest generates requests for GetIntegrationConfig
func NewGetIntegrationConfigRequest(server string, pType string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "type", runtime.ParamLocationPath, pType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/integrations-catalog/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteIntegrationV2Request generates requests for DeleteIntegrationV2
func NewDeleteIntegrationV2Request(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/integrations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIntegrationV2Request generates requests for GetIntegrationV2
func NewGetIntegrationV2Request(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/integrations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateIntegrationV2Request calls the generic UpdateIntegrationV2 builder with application/json body
func NewUpdateIntegrationV2Request(server string, id string, body UpdateIntegrationV2JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateIntegrationV2RequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateIntegrationV2RequestWithBody generates requests for UpdateIntegrationV2 with any type of body
func NewUpdateIntegrationV2RequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/integrations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRefreshIntegrationV2Request generates requests for RefreshIntegrationV2
func NewRefreshIntegrationV2Request(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/integrations/%s/refresh", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListUsersRequest generates requests for ListUsers
func NewListUsersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserRequest generates requests for GetUser
func NewGetUserRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAccessFlowsRequest generates requests for ListAccessFlows
func NewListAccessFlowsRequest(server string, params *ListAccessFlowsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/access-flows")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Filters != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filters", runtime.ParamLocationQuery, *params.Filters); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OnlyActive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "only_active", runtime.ParamLocationQuery, *params.OnlyActive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAccessFlowRequest calls the generic CreateAccessFlow builder with application/json body
func NewCreateAccessFlowRequest(server string, body CreateAccessFlowJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAccessFlowRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAccessFlowRequestWithBody generates requests for CreateAccessFlow with any type of body
func NewCreateAccessFlowRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/access-flows")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAccessFlowRequest generates requests for DeleteAccessFlow
func NewDeleteAccessFlowRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/access-flows/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAccessFlowRequest generates requests for GetAccessFlow
func NewGetAccessFlowRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/access-flows/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAccessFlowRequest calls the generic UpdateAccessFlow builder with application/json body
func NewUpdateAccessFlowRequest(server string, id string, body UpdateAccessFlowJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAccessFlowRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateAccessFlowRequestWithBody generates requests for UpdateAccessFlow with any type of body
func NewUpdateAccessFlowRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/access-flows/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAccessRequestsRequest generates requests for ListAccessRequests
func NewListAccessRequestsRequest(server string, params *ListAccessRequestsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/access-requests")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.DaysOffset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "days_offset", runtime.ParamLocationQuery, *params.DaysOffset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.UserId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAccessRequestRequest calls the generic CreateAccessRequest builder with application/json body
func NewCreateAccessRequestRequest(server string, body CreateAccessRequestJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAccessRequestRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAccessRequestRequestWithBody generates requests for CreateAccessRequest with any type of body
func NewCreateAccessRequestRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/access-requests")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAccessRequestRequest generates requests for GetAccessRequest
func NewGetAccessRequestRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/access-requests/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAccessRequestDetailsRequest generates requests for GetAccessRequestDetails
func NewGetAccessRequestDetailsRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/access-requests/%s/access-details", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewResetAccessRequestCredentialsRequest generates requests for ResetAccessRequestCredentials
func NewResetAccessRequestCredentialsRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/access-requests/%s/reset", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListActivityRequest generates requests for ListActivity
func NewListActivityRequest(server string, params *ListActivityParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/activity")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.EndDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_date", runtime.ParamLocationQuery, *params.EndDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Fields != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterIntegrationId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[integration_id]", runtime.ParamLocationQuery, *params.FilterIntegrationId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterPermission != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[permission]", runtime.ParamLocationQuery, *params.FilterPermission); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterRequestorId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[requestor_id]", runtime.ParamLocationQuery, *params.FilterRequestorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterResource != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[resource]", runtime.ParamLocationQuery, *params.FilterResource); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterResourceType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[resource_type]", runtime.ParamLocationQuery, *params.FilterResourceType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterStatus != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[status]", runtime.ParamLocationQuery, *params.FilterStatus); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_date", runtime.ParamLocationQuery, *params.StartDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIntegrationPermissionsRequest generates requests for GetIntegrationPermissions
func NewGetIntegrationPermissionsRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/integrations/%s/permissions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIntegrationResourcesRequest generates requests for GetIntegrationResources
func NewGetIntegrationResourcesRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/integrations/%s/resources", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSelectableIntegrationsRequest generates requests for GetSelectableIntegrations
func NewGetSelectableIntegrationsRequest(server string, params *GetSelectableIntegrationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/selectable-integrations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.UserId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSelectableResourceTypesRequest generates requests for GetSelectableResourceTypes
func NewGetSelectableResourceTypesRequest(server string, integrationId string, params *GetSelectableResourceTypesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "integration_id", runtime.ParamLocationPath, integrationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/selectable-integrations/%s/resource-types", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.UserId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSelectablePermissionsRequest generates requests for GetSelectablePermissions
func NewGetSelectablePermissionsRequest(server string, integrationId string, resourceType string, params *GetSelectablePermissionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "integration_id", runtime.ParamLocationPath, integrationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "resource_type", runtime.ParamLocationPath, resourceType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/selectable-integrations/%s/%s/permissions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.UserId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSelectableResourcesRequest generates requests for GetSelectableResources
func NewGetSelectableResourcesRequest(server string, integrationId string, resourceType string, params *GetSelectableResourcesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "integration_id", runtime.ParamLocationPath, integrationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "resource_type", runtime.ParamLocationPath, resourceType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/selectable-integrations/%s/%s/resources", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.UserId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListConnectors request
	ListConnectorsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListConnectorsResponse, error)

	// ListIdentities request
	ListIdentitiesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListIdentitiesResponse, error)

	// ListIntegrationsV2 request
	ListIntegrationsV2WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListIntegrationsV2Response, error)

	// CreateIntegrationV2 request with any body
	CreateIntegrationV2WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIntegrationV2Response, error)

	CreateIntegrationV2WithResponse(ctx context.Context, body CreateIntegrationV2JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIntegrationV2Response, error)

	// ListIntegrationConfigs request
	ListIntegrationConfigsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListIntegrationConfigsResponse, error)

	// GetIntegrationConfig request
	GetIntegrationConfigWithResponse(ctx context.Context, pType string, reqEditors ...RequestEditorFn) (*GetIntegrationConfigResponse, error)

	// DeleteIntegrationV2 request
	DeleteIntegrationV2WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteIntegrationV2Response, error)

	// GetIntegrationV2 request
	GetIntegrationV2WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetIntegrationV2Response, error)

	// UpdateIntegrationV2 request with any body
	UpdateIntegrationV2WithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateIntegrationV2Response, error)

	UpdateIntegrationV2WithResponse(ctx context.Context, id string, body UpdateIntegrationV2JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateIntegrationV2Response, error)

	// RefreshIntegrationV2 request
	RefreshIntegrationV2WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RefreshIntegrationV2Response, error)

	// ListUsers request
	ListUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListUsersResponse, error)

	// GetUser request
	GetUserWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetUserResponse, error)

	// ListAccessFlows request
	ListAccessFlowsWithResponse(ctx context.Context, params *ListAccessFlowsParams, reqEditors ...RequestEditorFn) (*ListAccessFlowsResponse, error)

	// CreateAccessFlow request with any body
	CreateAccessFlowWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAccessFlowResponse, error)

	CreateAccessFlowWithResponse(ctx context.Context, body CreateAccessFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAccessFlowResponse, error)

	// DeleteAccessFlow request
	DeleteAccessFlowWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteAccessFlowResponse, error)

	// GetAccessFlow request
	GetAccessFlowWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAccessFlowResponse, error)

	// UpdateAccessFlow request with any body
	UpdateAccessFlowWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAccessFlowResponse, error)

	UpdateAccessFlowWithResponse(ctx context.Context, id string, body UpdateAccessFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAccessFlowResponse, error)

	// ListAccessRequests request
	ListAccessRequestsWithResponse(ctx context.Context, params *ListAccessRequestsParams, reqEditors ...RequestEditorFn) (*ListAccessRequestsResponse, error)

	// CreateAccessRequest request with any body
	CreateAccessRequestWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAccessRequestResponse, error)

	CreateAccessRequestWithResponse(ctx context.Context, body CreateAccessRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAccessRequestResponse, error)

	// GetAccessRequest request
	GetAccessRequestWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAccessRequestResponse, error)

	// GetAccessRequestDetails request
	GetAccessRequestDetailsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAccessRequestDetailsResponse, error)

	// ResetAccessRequestCredentials request
	ResetAccessRequestCredentialsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ResetAccessRequestCredentialsResponse, error)

	// ListActivity request
	ListActivityWithResponse(ctx context.Context, params *ListActivityParams, reqEditors ...RequestEditorFn) (*ListActivityResponse, error)

	// GetIntegrationPermissions request
	GetIntegrationPermissionsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetIntegrationPermissionsResponse, error)

	// GetIntegrationResources request
	GetIntegrationResourcesWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetIntegrationResourcesResponse, error)

	// GetSelectableIntegrations request
	GetSelectableIntegrationsWithResponse(ctx context.Context, params *GetSelectableIntegrationsParams, reqEditors ...RequestEditorFn) (*GetSelectableIntegrationsResponse, error)

	// GetSelectableResourceTypes request
	GetSelectableResourceTypesWithResponse(ctx context.Context, integrationId string, params *GetSelectableResourceTypesParams, reqEditors ...RequestEditorFn) (*GetSelectableResourceTypesResponse, error)

	// GetSelectablePermissions request
	GetSelectablePermissionsWithResponse(ctx context.Context, integrationId string, resourceType string, params *GetSelectablePermissionsParams, reqEditors ...RequestEditorFn) (*GetSelectablePermissionsResponse, error)

	// GetSelectableResources request
	GetSelectableResourcesWithResponse(ctx context.Context, integrationId string, resourceType string, params *GetSelectableResourcesParams, reqEditors ...RequestEditorFn) (*GetSelectableResourcesResponse, error)
}

type ListConnectorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Connector
}

// Status returns HTTPResponse.Status
func (r ListConnectorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListConnectorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListIdentitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedResponseIdentityModelV2
}

// Status returns HTTPResponse.Status
func (r ListIdentitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListIdentitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListIntegrationsV2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedResponseIntegrationModel
}

// Status returns HTTPResponse.Status
func (r ListIntegrationsV2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListIntegrationsV2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateIntegrationV2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Integration
}

// Status returns HTTPResponse.Status
func (r CreateIntegrationV2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateIntegrationV2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListIntegrationConfigsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedResponseIntegrationConfigPublicModel
}

// Status returns HTTPResponse.Status
func (r ListIntegrationConfigsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListIntegrationConfigsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIntegrationConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IntegrationConfig
}

// Status returns HTTPResponse.Status
func (r GetIntegrationConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIntegrationConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteIntegrationV2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MessageResponse
}

// Status returns HTTPResponse.Status
func (r DeleteIntegrationV2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteIntegrationV2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIntegrationV2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Integration
}

// Status returns HTTPResponse.Status
func (r GetIntegrationV2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIntegrationV2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateIntegrationV2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Integration
}

// Status returns HTTPResponse.Status
func (r UpdateIntegrationV2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateIntegrationV2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RefreshIntegrationV2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MessageResponse
}

// Status returns HTTPResponse.Status
func (r RefreshIntegrationV2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RefreshIntegrationV2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedResponseUserModel
}

// Status returns HTTPResponse.Status
func (r ListUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserModel
}

// Status returns HTTPResponse.Status
func (r GetUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAccessFlowsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedAccessFlowV3SearchResponse
}

// Status returns HTTPResponse.Status
func (r ListAccessFlowsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAccessFlowsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAccessFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccessFlowModelV3
}

// Status returns HTTPResponse.Status
func (r CreateAccessFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAccessFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAccessFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MessageResponse
}

// Status returns HTTPResponse.Status
func (r DeleteAccessFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAccessFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAccessFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccessFlowModelV3
}

// Status returns HTTPResponse.Status
func (r GetAccessFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccessFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAccessFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccessFlowModelV3
}

// Status returns HTTPResponse.Status
func (r UpdateAccessFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAccessFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAccessRequestsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedResponseAccessRequestV3
}

// Status returns HTTPResponse.Status
func (r ListAccessRequestsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAccessRequestsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAccessRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccessRequest
}

// Status returns HTTPResponse.Status
func (r CreateAccessRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAccessRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAccessRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccessRequest
}

// Status returns HTTPResponse.Status
func (r GetAccessRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccessRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAccessRequestDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConnectDetailsResponse
}

// Status returns HTTPResponse.Status
func (r GetAccessRequestDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccessRequestDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResetAccessRequestCredentialsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MessageResponse
}

// Status returns HTTPResponse.Status
func (r ResetAccessRequestCredentialsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResetAccessRequestCredentialsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListActivityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedResponseActivityReportJsonExportModel
}

// Status returns HTTPResponse.Status
func (r ListActivityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListActivityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIntegrationPermissionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedResponsePermissionV3Response
}

// Status returns HTTPResponse.Status
func (r GetIntegrationPermissionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIntegrationPermissionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIntegrationResourcesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedResponseResourceV3Response
}

// Status returns HTTPResponse.Status
func (r GetIntegrationResourcesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIntegrationResourcesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSelectableIntegrationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedResponseSelectableIntegrationV3
}

// Status returns HTTPResponse.Status
func (r GetSelectableIntegrationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSelectableIntegrationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSelectableResourceTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedResponseSelectableResourceTypeV3
}

// Status returns HTTPResponse.Status
func (r GetSelectableResourceTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSelectableResourceTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSelectablePermissionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SelectablePermissionsResponse
}

// Status returns HTTPResponse.Status
func (r GetSelectablePermissionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSelectablePermissionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSelectableResourcesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedResponseSelectableResourceV3
}

// Status returns HTTPResponse.Status
func (r GetSelectableResourcesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSelectableResourcesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListConnectorsWithResponse request returning *ListConnectorsResponse
func (c *ClientWithResponses) ListConnectorsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListConnectorsResponse, error) {
	rsp, err := c.ListConnectors(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListConnectorsResponse(rsp)
}

// ListIdentitiesWithResponse request returning *ListIdentitiesResponse
func (c *ClientWithResponses) ListIdentitiesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListIdentitiesResponse, error) {
	rsp, err := c.ListIdentities(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListIdentitiesResponse(rsp)
}

// ListIntegrationsV2WithResponse request returning *ListIntegrationsV2Response
func (c *ClientWithResponses) ListIntegrationsV2WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListIntegrationsV2Response, error) {
	rsp, err := c.ListIntegrationsV2(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListIntegrationsV2Response(rsp)
}

// CreateIntegrationV2WithBodyWithResponse request with arbitrary body returning *CreateIntegrationV2Response
func (c *ClientWithResponses) CreateIntegrationV2WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIntegrationV2Response, error) {
	rsp, err := c.CreateIntegrationV2WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIntegrationV2Response(rsp)
}

func (c *ClientWithResponses) CreateIntegrationV2WithResponse(ctx context.Context, body CreateIntegrationV2JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIntegrationV2Response, error) {
	rsp, err := c.CreateIntegrationV2(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIntegrationV2Response(rsp)
}

// ListIntegrationConfigsWithResponse request returning *ListIntegrationConfigsResponse
func (c *ClientWithResponses) ListIntegrationConfigsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListIntegrationConfigsResponse, error) {
	rsp, err := c.ListIntegrationConfigs(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListIntegrationConfigsResponse(rsp)
}

// GetIntegrationConfigWithResponse request returning *GetIntegrationConfigResponse
func (c *ClientWithResponses) GetIntegrationConfigWithResponse(ctx context.Context, pType string, reqEditors ...RequestEditorFn) (*GetIntegrationConfigResponse, error) {
	rsp, err := c.GetIntegrationConfig(ctx, pType, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIntegrationConfigResponse(rsp)
}

// DeleteIntegrationV2WithResponse request returning *DeleteIntegrationV2Response
func (c *ClientWithResponses) DeleteIntegrationV2WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteIntegrationV2Response, error) {
	rsp, err := c.DeleteIntegrationV2(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteIntegrationV2Response(rsp)
}

// GetIntegrationV2WithResponse request returning *GetIntegrationV2Response
func (c *ClientWithResponses) GetIntegrationV2WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetIntegrationV2Response, error) {
	rsp, err := c.GetIntegrationV2(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIntegrationV2Response(rsp)
}

// UpdateIntegrationV2WithBodyWithResponse request with arbitrary body returning *UpdateIntegrationV2Response
func (c *ClientWithResponses) UpdateIntegrationV2WithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateIntegrationV2Response, error) {
	rsp, err := c.UpdateIntegrationV2WithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateIntegrationV2Response(rsp)
}

func (c *ClientWithResponses) UpdateIntegrationV2WithResponse(ctx context.Context, id string, body UpdateIntegrationV2JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateIntegrationV2Response, error) {
	rsp, err := c.UpdateIntegrationV2(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateIntegrationV2Response(rsp)
}

// RefreshIntegrationV2WithResponse request returning *RefreshIntegrationV2Response
func (c *ClientWithResponses) RefreshIntegrationV2WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RefreshIntegrationV2Response, error) {
	rsp, err := c.RefreshIntegrationV2(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRefreshIntegrationV2Response(rsp)
}

// ListUsersWithResponse request returning *ListUsersResponse
func (c *ClientWithResponses) ListUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListUsersResponse, error) {
	rsp, err := c.ListUsers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUsersResponse(rsp)
}

// GetUserWithResponse request returning *GetUserResponse
func (c *ClientWithResponses) GetUserWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetUserResponse, error) {
	rsp, err := c.GetUser(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserResponse(rsp)
}

// ListAccessFlowsWithResponse request returning *ListAccessFlowsResponse
func (c *ClientWithResponses) ListAccessFlowsWithResponse(ctx context.Context, params *ListAccessFlowsParams, reqEditors ...RequestEditorFn) (*ListAccessFlowsResponse, error) {
	rsp, err := c.ListAccessFlows(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAccessFlowsResponse(rsp)
}

// CreateAccessFlowWithBodyWithResponse request with arbitrary body returning *CreateAccessFlowResponse
func (c *ClientWithResponses) CreateAccessFlowWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAccessFlowResponse, error) {
	rsp, err := c.CreateAccessFlowWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAccessFlowResponse(rsp)
}

func (c *ClientWithResponses) CreateAccessFlowWithResponse(ctx context.Context, body CreateAccessFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAccessFlowResponse, error) {
	rsp, err := c.CreateAccessFlow(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAccessFlowResponse(rsp)
}

// DeleteAccessFlowWithResponse request returning *DeleteAccessFlowResponse
func (c *ClientWithResponses) DeleteAccessFlowWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteAccessFlowResponse, error) {
	rsp, err := c.DeleteAccessFlow(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAccessFlowResponse(rsp)
}

// GetAccessFlowWithResponse request returning *GetAccessFlowResponse
func (c *ClientWithResponses) GetAccessFlowWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAccessFlowResponse, error) {
	rsp, err := c.GetAccessFlow(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccessFlowResponse(rsp)
}

// UpdateAccessFlowWithBodyWithResponse request with arbitrary body returning *UpdateAccessFlowResponse
func (c *ClientWithResponses) UpdateAccessFlowWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAccessFlowResponse, error) {
	rsp, err := c.UpdateAccessFlowWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAccessFlowResponse(rsp)
}

func (c *ClientWithResponses) UpdateAccessFlowWithResponse(ctx context.Context, id string, body UpdateAccessFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAccessFlowResponse, error) {
	rsp, err := c.UpdateAccessFlow(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAccessFlowResponse(rsp)
}

// ListAccessRequestsWithResponse request returning *ListAccessRequestsResponse
func (c *ClientWithResponses) ListAccessRequestsWithResponse(ctx context.Context, params *ListAccessRequestsParams, reqEditors ...RequestEditorFn) (*ListAccessRequestsResponse, error) {
	rsp, err := c.ListAccessRequests(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAccessRequestsResponse(rsp)
}

// CreateAccessRequestWithBodyWithResponse request with arbitrary body returning *CreateAccessRequestResponse
func (c *ClientWithResponses) CreateAccessRequestWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAccessRequestResponse, error) {
	rsp, err := c.CreateAccessRequestWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAccessRequestResponse(rsp)
}

func (c *ClientWithResponses) CreateAccessRequestWithResponse(ctx context.Context, body CreateAccessRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAccessRequestResponse, error) {
	rsp, err := c.CreateAccessRequest(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAccessRequestResponse(rsp)
}

// GetAccessRequestWithResponse request returning *GetAccessRequestResponse
func (c *ClientWithResponses) GetAccessRequestWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAccessRequestResponse, error) {
	rsp, err := c.GetAccessRequest(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccessRequestResponse(rsp)
}

// GetAccessRequestDetailsWithResponse request returning *GetAccessRequestDetailsResponse
func (c *ClientWithResponses) GetAccessRequestDetailsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAccessRequestDetailsResponse, error) {
	rsp, err := c.GetAccessRequestDetails(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccessRequestDetailsResponse(rsp)
}

// ResetAccessRequestCredentialsWithResponse request returning *ResetAccessRequestCredentialsResponse
func (c *ClientWithResponses) ResetAccessRequestCredentialsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ResetAccessRequestCredentialsResponse, error) {
	rsp, err := c.ResetAccessRequestCredentials(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetAccessRequestCredentialsResponse(rsp)
}

// ListActivityWithResponse request returning *ListActivityResponse
func (c *ClientWithResponses) ListActivityWithResponse(ctx context.Context, params *ListActivityParams, reqEditors ...RequestEditorFn) (*ListActivityResponse, error) {
	rsp, err := c.ListActivity(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListActivityResponse(rsp)
}

// GetIntegrationPermissionsWithResponse request returning *GetIntegrationPermissionsResponse
func (c *ClientWithResponses) GetIntegrationPermissionsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetIntegrationPermissionsResponse, error) {
	rsp, err := c.GetIntegrationPermissions(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIntegrationPermissionsResponse(rsp)
}

// GetIntegrationResourcesWithResponse request returning *GetIntegrationResourcesResponse
func (c *ClientWithResponses) GetIntegrationResourcesWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetIntegrationResourcesResponse, error) {
	rsp, err := c.GetIntegrationResources(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIntegrationResourcesResponse(rsp)
}

// GetSelectableIntegrationsWithResponse request returning *GetSelectableIntegrationsResponse
func (c *ClientWithResponses) GetSelectableIntegrationsWithResponse(ctx context.Context, params *GetSelectableIntegrationsParams, reqEditors ...RequestEditorFn) (*GetSelectableIntegrationsResponse, error) {
	rsp, err := c.GetSelectableIntegrations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSelectableIntegrationsResponse(rsp)
}

// GetSelectableResourceTypesWithResponse request returning *GetSelectableResourceTypesResponse
func (c *ClientWithResponses) GetSelectableResourceTypesWithResponse(ctx context.Context, integrationId string, params *GetSelectableResourceTypesParams, reqEditors ...RequestEditorFn) (*GetSelectableResourceTypesResponse, error) {
	rsp, err := c.GetSelectableResourceTypes(ctx, integrationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSelectableResourceTypesResponse(rsp)
}

// GetSelectablePermissionsWithResponse request returning *GetSelectablePermissionsResponse
func (c *ClientWithResponses) GetSelectablePermissionsWithResponse(ctx context.Context, integrationId string, resourceType string, params *GetSelectablePermissionsParams, reqEditors ...RequestEditorFn) (*GetSelectablePermissionsResponse, error) {
	rsp, err := c.GetSelectablePermissions(ctx, integrationId, resourceType, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSelectablePermissionsResponse(rsp)
}

// GetSelectableResourcesWithResponse request returning *GetSelectableResourcesResponse
func (c *ClientWithResponses) GetSelectableResourcesWithResponse(ctx context.Context, integrationId string, resourceType string, params *GetSelectableResourcesParams, reqEditors ...RequestEditorFn) (*GetSelectableResourcesResponse, error) {
	rsp, err := c.GetSelectableResources(ctx, integrationId, resourceType, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSelectableResourcesResponse(rsp)
}

// ParseListConnectorsResponse parses an HTTP response from a ListConnectorsWithResponse call
func ParseListConnectorsResponse(rsp *http.Response) (*ListConnectorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListConnectorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Connector
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListIdentitiesResponse parses an HTTP response from a ListIdentitiesWithResponse call
func ParseListIdentitiesResponse(rsp *http.Response) (*ListIdentitiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListIdentitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedResponseIdentityModelV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListIntegrationsV2Response parses an HTTP response from a ListIntegrationsV2WithResponse call
func ParseListIntegrationsV2Response(rsp *http.Response) (*ListIntegrationsV2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListIntegrationsV2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedResponseIntegrationModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateIntegrationV2Response parses an HTTP response from a CreateIntegrationV2WithResponse call
func ParseCreateIntegrationV2Response(rsp *http.Response) (*CreateIntegrationV2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateIntegrationV2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Integration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListIntegrationConfigsResponse parses an HTTP response from a ListIntegrationConfigsWithResponse call
func ParseListIntegrationConfigsResponse(rsp *http.Response) (*ListIntegrationConfigsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListIntegrationConfigsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedResponseIntegrationConfigPublicModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetIntegrationConfigResponse parses an HTTP response from a GetIntegrationConfigWithResponse call
func ParseGetIntegrationConfigResponse(rsp *http.Response) (*GetIntegrationConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIntegrationConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IntegrationConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteIntegrationV2Response parses an HTTP response from a DeleteIntegrationV2WithResponse call
func ParseDeleteIntegrationV2Response(rsp *http.Response) (*DeleteIntegrationV2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteIntegrationV2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MessageResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetIntegrationV2Response parses an HTTP response from a GetIntegrationV2WithResponse call
func ParseGetIntegrationV2Response(rsp *http.Response) (*GetIntegrationV2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIntegrationV2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Integration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateIntegrationV2Response parses an HTTP response from a UpdateIntegrationV2WithResponse call
func ParseUpdateIntegrationV2Response(rsp *http.Response) (*UpdateIntegrationV2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateIntegrationV2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Integration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRefreshIntegrationV2Response parses an HTTP response from a RefreshIntegrationV2WithResponse call
func ParseRefreshIntegrationV2Response(rsp *http.Response) (*RefreshIntegrationV2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RefreshIntegrationV2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MessageResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListUsersResponse parses an HTTP response from a ListUsersWithResponse call
func ParseListUsersResponse(rsp *http.Response) (*ListUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedResponseUserModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUserResponse parses an HTTP response from a GetUserWithResponse call
func ParseGetUserResponse(rsp *http.Response) (*GetUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListAccessFlowsResponse parses an HTTP response from a ListAccessFlowsWithResponse call
func ParseListAccessFlowsResponse(rsp *http.Response) (*ListAccessFlowsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAccessFlowsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedAccessFlowV3SearchResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateAccessFlowResponse parses an HTTP response from a CreateAccessFlowWithResponse call
func ParseCreateAccessFlowResponse(rsp *http.Response) (*CreateAccessFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAccessFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccessFlowModelV3
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteAccessFlowResponse parses an HTTP response from a DeleteAccessFlowWithResponse call
func ParseDeleteAccessFlowResponse(rsp *http.Response) (*DeleteAccessFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAccessFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MessageResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAccessFlowResponse parses an HTTP response from a GetAccessFlowWithResponse call
func ParseGetAccessFlowResponse(rsp *http.Response) (*GetAccessFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccessFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccessFlowModelV3
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateAccessFlowResponse parses an HTTP response from a UpdateAccessFlowWithResponse call
func ParseUpdateAccessFlowResponse(rsp *http.Response) (*UpdateAccessFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAccessFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccessFlowModelV3
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListAccessRequestsResponse parses an HTTP response from a ListAccessRequestsWithResponse call
func ParseListAccessRequestsResponse(rsp *http.Response) (*ListAccessRequestsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAccessRequestsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedResponseAccessRequestV3
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateAccessRequestResponse parses an HTTP response from a CreateAccessRequestWithResponse call
func ParseCreateAccessRequestResponse(rsp *http.Response) (*CreateAccessRequestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAccessRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccessRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAccessRequestResponse parses an HTTP response from a GetAccessRequestWithResponse call
func ParseGetAccessRequestResponse(rsp *http.Response) (*GetAccessRequestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccessRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccessRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAccessRequestDetailsResponse parses an HTTP response from a GetAccessRequestDetailsWithResponse call
func ParseGetAccessRequestDetailsResponse(rsp *http.Response) (*GetAccessRequestDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccessRequestDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConnectDetailsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseResetAccessRequestCredentialsResponse parses an HTTP response from a ResetAccessRequestCredentialsWithResponse call
func ParseResetAccessRequestCredentialsResponse(rsp *http.Response) (*ResetAccessRequestCredentialsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResetAccessRequestCredentialsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MessageResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListActivityResponse parses an HTTP response from a ListActivityWithResponse call
func ParseListActivityResponse(rsp *http.Response) (*ListActivityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListActivityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedResponseActivityReportJsonExportModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetIntegrationPermissionsResponse parses an HTTP response from a GetIntegrationPermissionsWithResponse call
func ParseGetIntegrationPermissionsResponse(rsp *http.Response) (*GetIntegrationPermissionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIntegrationPermissionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedResponsePermissionV3Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetIntegrationResourcesResponse parses an HTTP response from a GetIntegrationResourcesWithResponse call
func ParseGetIntegrationResourcesResponse(rsp *http.Response) (*GetIntegrationResourcesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIntegrationResourcesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedResponseResourceV3Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSelectableIntegrationsResponse parses an HTTP response from a GetSelectableIntegrationsWithResponse call
func ParseGetSelectableIntegrationsResponse(rsp *http.Response) (*GetSelectableIntegrationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSelectableIntegrationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedResponseSelectableIntegrationV3
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSelectableResourceTypesResponse parses an HTTP response from a GetSelectableResourceTypesWithResponse call
func ParseGetSelectableResourceTypesResponse(rsp *http.Response) (*GetSelectableResourceTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSelectableResourceTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedResponseSelectableResourceTypeV3
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSelectablePermissionsResponse parses an HTTP response from a GetSelectablePermissionsWithResponse call
func ParseGetSelectablePermissionsResponse(rsp *http.Response) (*GetSelectablePermissionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSelectablePermissionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SelectablePermissionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSelectableResourcesResponse parses an HTTP response from a GetSelectableResourcesWithResponse call
func ParseGetSelectableResourcesResponse(rsp *http.Response) (*GetSelectableResourcesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSelectableResourcesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedResponseSelectableResourceV3
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
