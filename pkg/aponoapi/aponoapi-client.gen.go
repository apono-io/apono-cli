// Package aponoapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package aponoapi

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

const (
	AuthorizationScopes = "Authorization.Scopes"
)

// Defines values for AccessStatusModel.
const (
	APPROVED AccessStatusModel = "APPROVED"
	EXPIRED  AccessStatusModel = "EXPIRED"
	FAILED   AccessStatusModel = "FAILED"
	GRANTED  AccessStatusModel = "GRANTED"
	PENDING  AccessStatusModel = "PENDING"
	REJECTED AccessStatusModel = "REJECTED"
	REVOKING AccessStatusModel = "REVOKING"
)

// Defines values for IntegrationStatus.
const (
	Active       IntegrationStatus = "Active"
	Disabled     IntegrationStatus = "Disabled"
	Error        IntegrationStatus = "Error"
	Initializing IntegrationStatus = "Initializing"
	Refreshing   IntegrationStatus = "Refreshing"
	Warning      IntegrationStatus = "Warning"
)

// AccessRequest defines model for AccessRequest.
type AccessRequest struct {
	FriendlyRequestId string            `json:"friendly_request_id"`
	IntegrationId     string            `json:"integration_id"`
	Justification     string            `json:"justification"`
	Permissions       []string          `json:"permissions"`
	RequestId         string            `json:"request_id"`
	ResourceIds       []string          `json:"resource_ids"`
	Status            AccessStatusModel `json:"status"`
	UserId            string            `json:"user_id"`
}

// AccessStatusModel defines model for AccessStatusModel.
type AccessStatusModel string

// ConnectionMetadata defines model for ConnectionMetadata.
type ConnectionMetadata = map[string]interface{}

// Connector defines model for Connector.
type Connector struct {
	ConnectorId   string   `json:"connector_id"`
	LastConnected *Instant `json:"last_connected"`
	Status        string   `json:"status"`
}

// CreateAccessRequest defines model for CreateAccessRequest.
type CreateAccessRequest struct {
	IntegrationId string   `json:"integration_id"`
	Justification string   `json:"justification"`
	Permissions   []string `json:"permissions"`
	ResourceIds   []string `json:"resource_ids"`
	UserId        string   `json:"user_id"`
}

// CreateIntegration defines model for CreateIntegration.
type CreateIntegration struct {
	Metadata      map[string]interface{} `json:"metadata"`
	Name          string                 `json:"name"`
	ProvisionerId *string                `json:"provisioner_id"`
	SecretConfig  *SecretConfig          `json:"secret_config"`
	Type          string                 `json:"type"`
}

// Integration defines model for Integration.
type Integration struct {
	Connection    *ConnectionMetadata    `json:"connection"`
	Details       *string                `json:"details"`
	Id            string                 `json:"id"`
	LastSyncTime  *Instant               `json:"last_sync_time"`
	Metadata      map[string]interface{} `json:"metadata"`
	Name          string                 `json:"name"`
	ProvisionerId *string                `json:"provisioner_id"`
	SecretConfig  *SecretConfig          `json:"secret_config"`
	Status        IntegrationStatus      `json:"status"`
	Type          string                 `json:"type"`
}

// IntegrationConfig defines model for IntegrationConfig.
type IntegrationConfig struct {
	Description          string                   `json:"description"`
	Name                 string                   `json:"name"`
	Params               []IntegrationConfigParam `json:"params"`
	RequiresSecret       bool                     `json:"requires_secret"`
	SupportedSecretTypes []string                 `json:"supported_secret_types"`
	Type                 string                   `json:"type"`
}

// IntegrationConfigParam defines model for IntegrationConfigParam.
type IntegrationConfigParam struct {
	Default string   `json:"default"`
	Id      string   `json:"id"`
	Label   string   `json:"label"`
	Values  []string `json:"values"`
}

// IntegrationStatus defines model for IntegrationStatus.
type IntegrationStatus string

// MessageResponse defines model for MessageResponse.
type MessageResponse struct {
	Message string `json:"message"`
}

// PaginatedResponseAccessRequestV3 defines model for PaginatedResponseAccessRequestV3.
type PaginatedResponseAccessRequestV3 struct {
	Data       []AccessRequest `json:"data"`
	Pagination PaginationInfo  `json:"pagination"`
}

// PaginatedResponseIntegrationConfigPublicModel defines model for PaginatedResponseIntegrationConfigPublicModel.
type PaginatedResponseIntegrationConfigPublicModel struct {
	Data       []IntegrationConfig `json:"data"`
	Pagination PaginationInfo      `json:"pagination"`
}

// PaginatedResponseIntegrationModel defines model for PaginatedResponseIntegrationModel.
type PaginatedResponseIntegrationModel struct {
	Data       []Integration  `json:"data"`
	Pagination PaginationInfo `json:"pagination"`
}

// PaginatedResponseSelectableIntegrationV3 defines model for PaginatedResponseSelectableIntegrationV3.
type PaginatedResponseSelectableIntegrationV3 struct {
	Data       []SelectableIntegration `json:"data"`
	Pagination PaginationInfo          `json:"pagination"`
}

// PaginatedResponseSelectableResourceV3 defines model for PaginatedResponseSelectableResourceV3.
type PaginatedResponseSelectableResourceV3 struct {
	Data       []SelectableResource `json:"data"`
	Pagination PaginationInfo       `json:"pagination"`
}

// PaginatedResponseUserModel defines model for PaginatedResponseUserModel.
type PaginatedResponseUserModel struct {
	Data       []UserModel    `json:"data"`
	Pagination PaginationInfo `json:"pagination"`
}

// PaginationInfo defines model for PaginationInfo.
type PaginationInfo struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
	Total  int32 `json:"total"`
}

// SecretConfig defines model for SecretConfig.
type SecretConfig = map[string]interface{}

// SelectableIntegration defines model for SelectableIntegration.
type SelectableIntegration struct {
	Id string `json:"id"`
}

// SelectablePermissionsResponse defines model for SelectablePermissionsResponse.
type SelectablePermissionsResponse struct {
	AllowMultiple bool           `json:"allow_multiple"`
	Data          []string       `json:"data"`
	Pagination    PaginationInfo `json:"pagination"`
}

// SelectableResource defines model for SelectableResource.
type SelectableResource struct {
	Id   string `json:"id"`
	Name string `json:"name"`
}

// UpdateIntegration defines model for UpdateIntegration.
type UpdateIntegration struct {
	Metadata      map[string]interface{} `json:"metadata"`
	Name          string                 `json:"name"`
	ProvisionerId *string                `json:"provisioner_id"`
	SecretConfig  *SecretConfig          `json:"secret_config"`
}

// UserModel defines model for UserModel.
type UserModel struct {
	Email     string `json:"email"`
	FirstName string `json:"first_name"`
	Id        string `json:"id"`
	LastName  string `json:"last_name"`
}

// ListAccessRequestsParams defines parameters for ListAccessRequests.
type ListAccessRequestsParams struct {
	DaysOffset *int64  `form:"days_offset,omitempty" json:"days_offset,omitempty"`
	UserId     *string `form:"user_id,omitempty" json:"user_id,omitempty"`
}

// GetSelectableIntegrationsParams defines parameters for GetSelectableIntegrations.
type GetSelectableIntegrationsParams struct {
	UserId *string `form:"user_id,omitempty" json:"user_id,omitempty"`
}

// GetSelectablePermissionsParams defines parameters for GetSelectablePermissions.
type GetSelectablePermissionsParams struct {
	UserId *string `form:"user_id,omitempty" json:"user_id,omitempty"`
}

// GetSelectableResourcesParams defines parameters for GetSelectableResources.
type GetSelectableResourcesParams struct {
	UserId *string `form:"user_id,omitempty" json:"user_id,omitempty"`
}

// CreateIntegrationV2JSONRequestBody defines body for CreateIntegrationV2 for application/json ContentType.
type CreateIntegrationV2JSONRequestBody = CreateIntegration

// UpdateIntegrationV2JSONRequestBody defines body for UpdateIntegrationV2 for application/json ContentType.
type UpdateIntegrationV2JSONRequestBody = UpdateIntegration

// CreateAccessRequestJSONRequestBody defines body for CreateAccessRequest for application/json ContentType.
type CreateAccessRequestJSONRequestBody = CreateAccessRequest

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListConnectors request
	ListConnectors(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListIntegrationsV2 request
	ListIntegrationsV2(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateIntegrationV2 request with any body
	CreateIntegrationV2WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateIntegrationV2(ctx context.Context, body CreateIntegrationV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListIntegrationConfigs request
	ListIntegrationConfigs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIntegrationConfig request
	GetIntegrationConfig(ctx context.Context, pType string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteIntegrationV2 request
	DeleteIntegrationV2(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIntegrationV2 request
	GetIntegrationV2(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateIntegrationV2 request with any body
	UpdateIntegrationV2WithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateIntegrationV2(ctx context.Context, id string, body UpdateIntegrationV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RefreshIntegrationV2 request
	RefreshIntegrationV2(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUsers request
	ListUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUser request
	GetUser(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAccessRequests request
	ListAccessRequests(ctx context.Context, params *ListAccessRequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAccessRequest request with any body
	CreateAccessRequestWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAccessRequest(ctx context.Context, body CreateAccessRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAccessRequest request
	GetAccessRequest(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSelectableIntegrations request
	GetSelectableIntegrations(ctx context.Context, params *GetSelectableIntegrationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSelectablePermissions request
	GetSelectablePermissions(ctx context.Context, integrationId string, params *GetSelectablePermissionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSelectableResources request
	GetSelectableResources(ctx context.Context, integrationId string, params *GetSelectableResourcesParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListConnectors(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListConnectorsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListIntegrationsV2(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListIntegrationsV2Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIntegrationV2WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIntegrationV2RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIntegrationV2(ctx context.Context, body CreateIntegrationV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIntegrationV2Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListIntegrationConfigs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListIntegrationConfigsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIntegrationConfig(ctx context.Context, pType string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIntegrationConfigRequest(c.Server, pType)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteIntegrationV2(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteIntegrationV2Request(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIntegrationV2(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIntegrationV2Request(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateIntegrationV2WithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateIntegrationV2RequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateIntegrationV2(ctx context.Context, id string, body UpdateIntegrationV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateIntegrationV2Request(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RefreshIntegrationV2(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRefreshIntegrationV2Request(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUsersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUser(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAccessRequests(ctx context.Context, params *ListAccessRequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAccessRequestsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAccessRequestWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAccessRequestRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAccessRequest(ctx context.Context, body CreateAccessRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAccessRequestRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAccessRequest(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccessRequestRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSelectableIntegrations(ctx context.Context, params *GetSelectableIntegrationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSelectableIntegrationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSelectablePermissions(ctx context.Context, integrationId string, params *GetSelectablePermissionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSelectablePermissionsRequest(c.Server, integrationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSelectableResources(ctx context.Context, integrationId string, params *GetSelectableResourcesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSelectableResourcesRequest(c.Server, integrationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListConnectorsRequest generates requests for ListConnectors
func NewListConnectorsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/connectors")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListIntegrationsV2Request generates requests for ListIntegrationsV2
func NewListIntegrationsV2Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/integrations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateIntegrationV2Request calls the generic CreateIntegrationV2 builder with application/json body
func NewCreateIntegrationV2Request(server string, body CreateIntegrationV2JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateIntegrationV2RequestWithBody(server, "application/json", bodyReader)
}

// NewCreateIntegrationV2RequestWithBody generates requests for CreateIntegrationV2 with any type of body
func NewCreateIntegrationV2RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/integrations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListIntegrationConfigsRequest generates requests for ListIntegrationConfigs
func NewListIntegrationConfigsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/integrations-catalog")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIntegrationConfigRequest generates requests for GetIntegrationConfig
func NewGetIntegrationConfigRequest(server string, pType string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "type", runtime.ParamLocationPath, pType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/integrations-catalog/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteIntegrationV2Request generates requests for DeleteIntegrationV2
func NewDeleteIntegrationV2Request(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/integrations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIntegrationV2Request generates requests for GetIntegrationV2
func NewGetIntegrationV2Request(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/integrations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateIntegrationV2Request calls the generic UpdateIntegrationV2 builder with application/json body
func NewUpdateIntegrationV2Request(server string, id string, body UpdateIntegrationV2JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateIntegrationV2RequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateIntegrationV2RequestWithBody generates requests for UpdateIntegrationV2 with any type of body
func NewUpdateIntegrationV2RequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/integrations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRefreshIntegrationV2Request generates requests for RefreshIntegrationV2
func NewRefreshIntegrationV2Request(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/integrations/%s/refresh", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListUsersRequest generates requests for ListUsers
func NewListUsersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserRequest generates requests for GetUser
func NewGetUserRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAccessRequestsRequest generates requests for ListAccessRequests
func NewListAccessRequestsRequest(server string, params *ListAccessRequestsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/access-requests")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.DaysOffset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "days_offset", runtime.ParamLocationQuery, *params.DaysOffset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.UserId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAccessRequestRequest calls the generic CreateAccessRequest builder with application/json body
func NewCreateAccessRequestRequest(server string, body CreateAccessRequestJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAccessRequestRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAccessRequestRequestWithBody generates requests for CreateAccessRequest with any type of body
func NewCreateAccessRequestRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/access-requests")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAccessRequestRequest generates requests for GetAccessRequest
func NewGetAccessRequestRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/access-requests/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSelectableIntegrationsRequest generates requests for GetSelectableIntegrations
func NewGetSelectableIntegrationsRequest(server string, params *GetSelectableIntegrationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/selectable-integrations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.UserId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSelectablePermissionsRequest generates requests for GetSelectablePermissions
func NewGetSelectablePermissionsRequest(server string, integrationId string, params *GetSelectablePermissionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "integration_id", runtime.ParamLocationPath, integrationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/selectable-integrations/%s/permissions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.UserId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSelectableResourcesRequest generates requests for GetSelectableResources
func NewGetSelectableResourcesRequest(server string, integrationId string, params *GetSelectableResourcesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "integration_id", runtime.ParamLocationPath, integrationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v3/selectable-integrations/%s/resources", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.UserId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListConnectors request
	ListConnectorsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListConnectorsResponse, error)

	// ListIntegrationsV2 request
	ListIntegrationsV2WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListIntegrationsV2Response, error)

	// CreateIntegrationV2 request with any body
	CreateIntegrationV2WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIntegrationV2Response, error)

	CreateIntegrationV2WithResponse(ctx context.Context, body CreateIntegrationV2JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIntegrationV2Response, error)

	// ListIntegrationConfigs request
	ListIntegrationConfigsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListIntegrationConfigsResponse, error)

	// GetIntegrationConfig request
	GetIntegrationConfigWithResponse(ctx context.Context, pType string, reqEditors ...RequestEditorFn) (*GetIntegrationConfigResponse, error)

	// DeleteIntegrationV2 request
	DeleteIntegrationV2WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteIntegrationV2Response, error)

	// GetIntegrationV2 request
	GetIntegrationV2WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetIntegrationV2Response, error)

	// UpdateIntegrationV2 request with any body
	UpdateIntegrationV2WithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateIntegrationV2Response, error)

	UpdateIntegrationV2WithResponse(ctx context.Context, id string, body UpdateIntegrationV2JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateIntegrationV2Response, error)

	// RefreshIntegrationV2 request
	RefreshIntegrationV2WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RefreshIntegrationV2Response, error)

	// ListUsers request
	ListUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListUsersResponse, error)

	// GetUser request
	GetUserWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetUserResponse, error)

	// ListAccessRequests request
	ListAccessRequestsWithResponse(ctx context.Context, params *ListAccessRequestsParams, reqEditors ...RequestEditorFn) (*ListAccessRequestsResponse, error)

	// CreateAccessRequest request with any body
	CreateAccessRequestWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAccessRequestResponse, error)

	CreateAccessRequestWithResponse(ctx context.Context, body CreateAccessRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAccessRequestResponse, error)

	// GetAccessRequest request
	GetAccessRequestWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAccessRequestResponse, error)

	// GetSelectableIntegrations request
	GetSelectableIntegrationsWithResponse(ctx context.Context, params *GetSelectableIntegrationsParams, reqEditors ...RequestEditorFn) (*GetSelectableIntegrationsResponse, error)

	// GetSelectablePermissions request
	GetSelectablePermissionsWithResponse(ctx context.Context, integrationId string, params *GetSelectablePermissionsParams, reqEditors ...RequestEditorFn) (*GetSelectablePermissionsResponse, error)

	// GetSelectableResources request
	GetSelectableResourcesWithResponse(ctx context.Context, integrationId string, params *GetSelectableResourcesParams, reqEditors ...RequestEditorFn) (*GetSelectableResourcesResponse, error)
}

type ListConnectorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Connector
}

// Status returns HTTPResponse.Status
func (r ListConnectorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListConnectorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListIntegrationsV2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedResponseIntegrationModel
}

// Status returns HTTPResponse.Status
func (r ListIntegrationsV2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListIntegrationsV2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateIntegrationV2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Integration
}

// Status returns HTTPResponse.Status
func (r CreateIntegrationV2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateIntegrationV2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListIntegrationConfigsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedResponseIntegrationConfigPublicModel
}

// Status returns HTTPResponse.Status
func (r ListIntegrationConfigsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListIntegrationConfigsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIntegrationConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IntegrationConfig
}

// Status returns HTTPResponse.Status
func (r GetIntegrationConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIntegrationConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteIntegrationV2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MessageResponse
}

// Status returns HTTPResponse.Status
func (r DeleteIntegrationV2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteIntegrationV2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIntegrationV2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Integration
}

// Status returns HTTPResponse.Status
func (r GetIntegrationV2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIntegrationV2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateIntegrationV2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Integration
}

// Status returns HTTPResponse.Status
func (r UpdateIntegrationV2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateIntegrationV2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RefreshIntegrationV2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MessageResponse
}

// Status returns HTTPResponse.Status
func (r RefreshIntegrationV2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RefreshIntegrationV2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedResponseUserModel
}

// Status returns HTTPResponse.Status
func (r ListUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserModel
}

// Status returns HTTPResponse.Status
func (r GetUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAccessRequestsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedResponseAccessRequestV3
}

// Status returns HTTPResponse.Status
func (r ListAccessRequestsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAccessRequestsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAccessRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccessRequest
}

// Status returns HTTPResponse.Status
func (r CreateAccessRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAccessRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAccessRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccessRequest
}

// Status returns HTTPResponse.Status
func (r GetAccessRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccessRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSelectableIntegrationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedResponseSelectableIntegrationV3
}

// Status returns HTTPResponse.Status
func (r GetSelectableIntegrationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSelectableIntegrationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSelectablePermissionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SelectablePermissionsResponse
}

// Status returns HTTPResponse.Status
func (r GetSelectablePermissionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSelectablePermissionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSelectableResourcesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedResponseSelectableResourceV3
}

// Status returns HTTPResponse.Status
func (r GetSelectableResourcesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSelectableResourcesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListConnectorsWithResponse request returning *ListConnectorsResponse
func (c *ClientWithResponses) ListConnectorsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListConnectorsResponse, error) {
	rsp, err := c.ListConnectors(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListConnectorsResponse(rsp)
}

// ListIntegrationsV2WithResponse request returning *ListIntegrationsV2Response
func (c *ClientWithResponses) ListIntegrationsV2WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListIntegrationsV2Response, error) {
	rsp, err := c.ListIntegrationsV2(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListIntegrationsV2Response(rsp)
}

// CreateIntegrationV2WithBodyWithResponse request with arbitrary body returning *CreateIntegrationV2Response
func (c *ClientWithResponses) CreateIntegrationV2WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIntegrationV2Response, error) {
	rsp, err := c.CreateIntegrationV2WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIntegrationV2Response(rsp)
}

func (c *ClientWithResponses) CreateIntegrationV2WithResponse(ctx context.Context, body CreateIntegrationV2JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIntegrationV2Response, error) {
	rsp, err := c.CreateIntegrationV2(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIntegrationV2Response(rsp)
}

// ListIntegrationConfigsWithResponse request returning *ListIntegrationConfigsResponse
func (c *ClientWithResponses) ListIntegrationConfigsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListIntegrationConfigsResponse, error) {
	rsp, err := c.ListIntegrationConfigs(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListIntegrationConfigsResponse(rsp)
}

// GetIntegrationConfigWithResponse request returning *GetIntegrationConfigResponse
func (c *ClientWithResponses) GetIntegrationConfigWithResponse(ctx context.Context, pType string, reqEditors ...RequestEditorFn) (*GetIntegrationConfigResponse, error) {
	rsp, err := c.GetIntegrationConfig(ctx, pType, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIntegrationConfigResponse(rsp)
}

// DeleteIntegrationV2WithResponse request returning *DeleteIntegrationV2Response
func (c *ClientWithResponses) DeleteIntegrationV2WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteIntegrationV2Response, error) {
	rsp, err := c.DeleteIntegrationV2(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteIntegrationV2Response(rsp)
}

// GetIntegrationV2WithResponse request returning *GetIntegrationV2Response
func (c *ClientWithResponses) GetIntegrationV2WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetIntegrationV2Response, error) {
	rsp, err := c.GetIntegrationV2(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIntegrationV2Response(rsp)
}

// UpdateIntegrationV2WithBodyWithResponse request with arbitrary body returning *UpdateIntegrationV2Response
func (c *ClientWithResponses) UpdateIntegrationV2WithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateIntegrationV2Response, error) {
	rsp, err := c.UpdateIntegrationV2WithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateIntegrationV2Response(rsp)
}

func (c *ClientWithResponses) UpdateIntegrationV2WithResponse(ctx context.Context, id string, body UpdateIntegrationV2JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateIntegrationV2Response, error) {
	rsp, err := c.UpdateIntegrationV2(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateIntegrationV2Response(rsp)
}

// RefreshIntegrationV2WithResponse request returning *RefreshIntegrationV2Response
func (c *ClientWithResponses) RefreshIntegrationV2WithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*RefreshIntegrationV2Response, error) {
	rsp, err := c.RefreshIntegrationV2(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRefreshIntegrationV2Response(rsp)
}

// ListUsersWithResponse request returning *ListUsersResponse
func (c *ClientWithResponses) ListUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListUsersResponse, error) {
	rsp, err := c.ListUsers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUsersResponse(rsp)
}

// GetUserWithResponse request returning *GetUserResponse
func (c *ClientWithResponses) GetUserWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetUserResponse, error) {
	rsp, err := c.GetUser(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserResponse(rsp)
}

// ListAccessRequestsWithResponse request returning *ListAccessRequestsResponse
func (c *ClientWithResponses) ListAccessRequestsWithResponse(ctx context.Context, params *ListAccessRequestsParams, reqEditors ...RequestEditorFn) (*ListAccessRequestsResponse, error) {
	rsp, err := c.ListAccessRequests(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAccessRequestsResponse(rsp)
}

// CreateAccessRequestWithBodyWithResponse request with arbitrary body returning *CreateAccessRequestResponse
func (c *ClientWithResponses) CreateAccessRequestWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAccessRequestResponse, error) {
	rsp, err := c.CreateAccessRequestWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAccessRequestResponse(rsp)
}

func (c *ClientWithResponses) CreateAccessRequestWithResponse(ctx context.Context, body CreateAccessRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAccessRequestResponse, error) {
	rsp, err := c.CreateAccessRequest(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAccessRequestResponse(rsp)
}

// GetAccessRequestWithResponse request returning *GetAccessRequestResponse
func (c *ClientWithResponses) GetAccessRequestWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAccessRequestResponse, error) {
	rsp, err := c.GetAccessRequest(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccessRequestResponse(rsp)
}

// GetSelectableIntegrationsWithResponse request returning *GetSelectableIntegrationsResponse
func (c *ClientWithResponses) GetSelectableIntegrationsWithResponse(ctx context.Context, params *GetSelectableIntegrationsParams, reqEditors ...RequestEditorFn) (*GetSelectableIntegrationsResponse, error) {
	rsp, err := c.GetSelectableIntegrations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSelectableIntegrationsResponse(rsp)
}

// GetSelectablePermissionsWithResponse request returning *GetSelectablePermissionsResponse
func (c *ClientWithResponses) GetSelectablePermissionsWithResponse(ctx context.Context, integrationId string, params *GetSelectablePermissionsParams, reqEditors ...RequestEditorFn) (*GetSelectablePermissionsResponse, error) {
	rsp, err := c.GetSelectablePermissions(ctx, integrationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSelectablePermissionsResponse(rsp)
}

// GetSelectableResourcesWithResponse request returning *GetSelectableResourcesResponse
func (c *ClientWithResponses) GetSelectableResourcesWithResponse(ctx context.Context, integrationId string, params *GetSelectableResourcesParams, reqEditors ...RequestEditorFn) (*GetSelectableResourcesResponse, error) {
	rsp, err := c.GetSelectableResources(ctx, integrationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSelectableResourcesResponse(rsp)
}

// ParseListConnectorsResponse parses an HTTP response from a ListConnectorsWithResponse call
func ParseListConnectorsResponse(rsp *http.Response) (*ListConnectorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListConnectorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Connector
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListIntegrationsV2Response parses an HTTP response from a ListIntegrationsV2WithResponse call
func ParseListIntegrationsV2Response(rsp *http.Response) (*ListIntegrationsV2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListIntegrationsV2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedResponseIntegrationModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateIntegrationV2Response parses an HTTP response from a CreateIntegrationV2WithResponse call
func ParseCreateIntegrationV2Response(rsp *http.Response) (*CreateIntegrationV2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateIntegrationV2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Integration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListIntegrationConfigsResponse parses an HTTP response from a ListIntegrationConfigsWithResponse call
func ParseListIntegrationConfigsResponse(rsp *http.Response) (*ListIntegrationConfigsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListIntegrationConfigsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedResponseIntegrationConfigPublicModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetIntegrationConfigResponse parses an HTTP response from a GetIntegrationConfigWithResponse call
func ParseGetIntegrationConfigResponse(rsp *http.Response) (*GetIntegrationConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIntegrationConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IntegrationConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteIntegrationV2Response parses an HTTP response from a DeleteIntegrationV2WithResponse call
func ParseDeleteIntegrationV2Response(rsp *http.Response) (*DeleteIntegrationV2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteIntegrationV2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MessageResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetIntegrationV2Response parses an HTTP response from a GetIntegrationV2WithResponse call
func ParseGetIntegrationV2Response(rsp *http.Response) (*GetIntegrationV2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIntegrationV2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Integration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateIntegrationV2Response parses an HTTP response from a UpdateIntegrationV2WithResponse call
func ParseUpdateIntegrationV2Response(rsp *http.Response) (*UpdateIntegrationV2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateIntegrationV2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Integration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRefreshIntegrationV2Response parses an HTTP response from a RefreshIntegrationV2WithResponse call
func ParseRefreshIntegrationV2Response(rsp *http.Response) (*RefreshIntegrationV2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RefreshIntegrationV2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MessageResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListUsersResponse parses an HTTP response from a ListUsersWithResponse call
func ParseListUsersResponse(rsp *http.Response) (*ListUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedResponseUserModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUserResponse parses an HTTP response from a GetUserWithResponse call
func ParseGetUserResponse(rsp *http.Response) (*GetUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListAccessRequestsResponse parses an HTTP response from a ListAccessRequestsWithResponse call
func ParseListAccessRequestsResponse(rsp *http.Response) (*ListAccessRequestsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAccessRequestsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedResponseAccessRequestV3
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateAccessRequestResponse parses an HTTP response from a CreateAccessRequestWithResponse call
func ParseCreateAccessRequestResponse(rsp *http.Response) (*CreateAccessRequestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAccessRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccessRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAccessRequestResponse parses an HTTP response from a GetAccessRequestWithResponse call
func ParseGetAccessRequestResponse(rsp *http.Response) (*GetAccessRequestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccessRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccessRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSelectableIntegrationsResponse parses an HTTP response from a GetSelectableIntegrationsWithResponse call
func ParseGetSelectableIntegrationsResponse(rsp *http.Response) (*GetSelectableIntegrationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSelectableIntegrationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedResponseSelectableIntegrationV3
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSelectablePermissionsResponse parses an HTTP response from a GetSelectablePermissionsWithResponse call
func ParseGetSelectablePermissionsResponse(rsp *http.Response) (*GetSelectablePermissionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSelectablePermissionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SelectablePermissionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSelectableResourcesResponse parses an HTTP response from a GetSelectableResourcesWithResponse call
func ParseGetSelectableResourcesResponse(rsp *http.Response) (*GetSelectableResourcesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSelectableResourcesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedResponseSelectableResourceV3
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
